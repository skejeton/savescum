import (
  "th.um"
  "rect.um"
  "../util.um"
  "canvas.um"
)

// NODE: by default each grid cell is exactly 1 unit, you can fix that by simply scaling it
type Grid* = struct {
  bb: rect::Rect
  p: th::Vf2
  s: th::Vf2
}

type RenderGuide* = struct {
  startv: th::Vf2 // offset at which first vertical line start 
  starth: th::Vf2 // offset at which first horizontal line start 
  endv: th::Vf2 // offset at which first vertical line ends
  endh: th::Vf2 // offset at which first horizontal line ends
  spacingv: th::Vf2 // spacing between each vertical line
  spacingh: th::Vf2 // spacing beween each horizontal line
  nv, nh: int // count of lines
}

fn (grid: ^Grid) toGridRel*(screen: th::Vf2): th::Vf2 {
  return screen.div(grid.s).sub(grid.p)
}

fn (grid: ^Grid) toGrid*(screen: th::Vf2): th::Vf2 {
  return screen.sub(grid.bb.getPos()).div(grid.s).sub(grid.p)
}

fn (grid: ^Grid) toScreen*(gridp: th::Vf2): th::Vf2 {
  return gridp.add(grid.p).mul(grid.s).add(grid.bb.getPos())
}

fn gridPan*(grid: ^Grid, delta: th::Vf2) {
  grid.p = grid.p.add(delta.div(grid.s))
}

// NOTE: into is a screen coordiante
fn gridZoomInto*(grid: ^Grid, newScale: th::Vf2, into: th::Vf2) {
  before := grid.toGrid(into)
  grid.s = newScale
  now := grid.toGrid(into)
  grid.p = grid.p.add(now.sub(before))
}

fn mkRenderGuideFromBoundingBox*(grid: Grid): RenderGuide {
  bb := grid.bb
  starters := th::Vf2{util::fmod(grid.p.x, 1)*grid.s.x, util::fmod(grid.p.y, 1)*grid.s.y}


  return RenderGuide {
    startv: th::Vf2{starters.x+bb.x, bb.y},
    starth: th::Vf2{bb.x, starters.y+bb.y},
    endv: th::Vf2{starters.x+bb.x, bb.h+bb.y},

    endh: th::Vf2{bb.w+bb.x, starters.y+bb.y},
    spacingv: th::Vf2{grid.s.x, 0},
    spacingh: th::Vf2{0, grid.s.y},
    nv: floor((bb.w-starters.x)/grid.s.x)+1,
    nh: floor((bb.h-starters.y)/grid.s.y)+1}
}

fn drawRenderGuide*(renderGuide: RenderGuide, color: uint32, thickness: real) {
  for i := 0; i < renderGuide.nv; i++ {
    sp := renderGuide.spacingv.mulf(i)
    canvas::drawLine(color, renderGuide.startv.add(sp), renderGuide.endv.add(sp), thickness)
  }

  for i := 0; i < renderGuide.nh; i++ {
    sp := renderGuide.spacingh.mulf(i)
    canvas::drawLine(color, renderGuide.starth.add(sp), renderGuide.endh.add(sp), thickness)
  }
}
